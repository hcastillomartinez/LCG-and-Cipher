# LCG-and-Cipher

## Description
Create an implementation of a Linear Congruential Generator that can be used to create a sequence of pseudo random numbers. You will then use your LCG as part of a cipher algorithm to encrypt and decrypt text. This assignment was mean to give some practice using structs, pointers, and header files.

### LCG Initialization
Given the values
m   : a 64-bit positive integer used as an LCG modulus,
c   : a 64-bit positive integer used as an LCG increment.
we can define a Linear Congruential Generator:
Xn+1 = (aXn  +c) modm
Where
X0 = c  
a = 1+ 2p  , if 4 is a factor of m  , otherwise, a = 1+ p  .
p =   (product of m  ’s unique prime factors).
0 < m  
0 < a < m  
0 ≤ c < m  
If the values given result in an invalid LCG, set all the fields to zero to indicate an error.

### Cipher Data
The cipher algorithm used in this project:

Encrypts plain text messages consisting solely of the printable ASCII characters.
Decrypts ciphertext consisting solely of the printable ASCII characters.
The printable ASCII characters are 8-bit codes in the range of values from 32 to 126 (00100000 through 01111110). See https://en.wikipedia.org/wiki/ASCII
Any 8-bit sequences outside of this range constitutes invalid data.

### Cipher Record Format
Each cipher record must be of the form:

Action:	lcg_m	,	lcg_c	,	Data	\n



Action:


Must be either ‘e’ or ‘d’, specifying encryption or decryption respectively.
lcg_m:
Specifies a 64-bit positive integer used for m of a Linear Congruential Generator. Must be decimal digits.
lcg_c:
Specifies a 64-bit positive integer used for c of a Linear Congruential Generator. Must be decimal digits.
Data:
Printable ASCII character data to be encrypted or decrypted. Can be empty or arbitrarily long. Note: with the given algorithm there will be no need to keep the full line of data in memory.

### Algorithm Summary
Determine the Linear Congruential Generator specified by the given key. This is done only once per line of input.
Read 1 byte of data b
Generate random value x
Compute encrypted byte as b XOR (x mod 128)
Deal with any non-printable ASCII characters.
Print the resulting character(s) to the standard output stream.
Return to step 2 and continue until the end of the line
Note: (A XOR B) XOR B = A, so we are able to decrypt our message reapplying the same XOR operation. (When decrypting, you will deal with special characters first, then XOR to decrypt back to the original plaintext character.)

### Initialization
Given a 128-bit symmetric key consisting of


m   : a 64-bit positive integer used as an LCG modulus


c   : a 64-bit positive integer used as an LCG increment

### Reading Data Bytes
Within each record, the data portion is the set of characters between the second comma and ’\n’.
When encrypting: Used getchar() to read 1 byte of data to encrypt.
When decrypting: Reading in an encrypted byte required reading 2 bytes from standard input since some character codes have 2-byte ciphertext representations.
Any character in the data segment not in the range of printable ASCII characters (32 to 126) is an error.


### Non-printable ASCII characters
This cipher algorithm can generate target bytes that are outside the range of printable ASCII.
When encrypting, if a generated byte e is:
< 32  	Replace with two bytes: ’*’ and ’?’+e.
= 127  	Replace with two bytes: ’*’ and ’!’.
=’*’	Replace with two bytes: ’*’ and ’*’.
When decrypting, if a generated byte p is a non-printing ASCII character, then print the specified error message and read to the end of line.

## example
./cipher <cipherdata.in
